version: v2beta1
name: stalker

vars:
  STALKER_ENVIRONMENT: dev

imports:
  - path: devspace.dev.yaml
    enabled: $(is_equal ${STALKER_ENVIRONMENT} "dev")
  - path: devspace.base.yaml

pipelines:
  build:
    run: build_images ui flow-manager orchestrator python-job-base nuclei-job-base

  deploy:
    run: |-
      build_images ui flow-manager orchestrator python-job-base nuclei-job-base
      create_deployments mongo ui flow-manager kafka orchestrator-service-account orchestrator --sequential

  dev:
    run: |-
      create_deployments namespaces
      build_images ui flow-manager orchestrator python-job-base nuclei-job-base cron-service
      create_deployments mongo kafka --sequential

      # Start mongo and kafka
      start_dev mongo kafka

      # Wait for kafka and mongo to be ready
      wait_pod --label-selector app.kubernetes.io/component=mongodb --timeout 300
      wait_pod --label-selector app.kubernetes.io/component=kafka --timeout 300
      wait_pod --label-selector app.kubernetes.io/component=zookeeper --timeout 300

      create_deployments ui flow-manager orchestrator-service-account orchestrator cron-service --sequential

      # Wait for services before applying network policies
      wait_pod --label-selector app.kubernetes.io/component=ui --timeout 300
      wait_pod --label-selector app.kubernetes.io/component=flow-manager --timeout 300
      wait_pod --label-selector app.kubernetes.io/component=orchestrator --timeout 300


      create_deployments network-policies
      create_deployments resource-quotas

      # Start microservices + ui
      start_dev orchestrator flow-manager ui

      create_deployments cron-service

      wait_pod --label-selector app.kubernetes.io/component=cron-service --timeout 300

      start_dev cron-service

  flow-manager-e2e:
    flags:
      - name: watch
        short: w
        type: bool
    run: |-
      create_deployments namespaces
      build_images flow-manager-e2e orchestrator python-job-base nuclei-job-base
      create_deployments mongo kafka orchestrator-service-account orchestrator flow-manager-e2e --sequential

      # Wait for kafka and mongo to be ready
      wait_pod --label-selector app.kubernetes.io/component=mongodb --timeout 300
      wait_pod --label-selector app.kubernetes.io/component=kafka --timeout 600
      wait_pod --label-selector app.kubernetes.io/component=zookeeper --timeout 300

      # Run tests
      if [ $(get_flag "watch") == "true" ]; 
      then
        echo "Running tests in watch mode."
        start_dev flow-manager-e2e mongo
        exec_container --label-selector app.kubernetes.io/component=flow-manager-e2e -n stalker -- /bin/sh -c 'npm run test:e2e:watch'
      else
        echo "Running tests in ci mode."
        start_dev flow-manager-e2e
        exec_container --label-selector app.kubernetes.io/component=flow-manager-e2e -n stalker -- /bin/sh -c 'npm run test:e2e:cicd' 2>&1
      fi
      stop_dev --all
  purge:
    run: |-
      stop_dev --all
      purge_deployments mongo ui flow-manager flow-manager-e2e kafka orchestrator-service-account orchestrator cron-service --sequential

  build-e2e:
    run: build_images ui flow-manager-e2e orchestrator python-job-base nuclei-job-base

  flow-manager-e2e-cicd-deploy:
    run: |-
      # Running the build pipeline is required before running this
      create_deployments namespaces
      create_deployments mongo kafka orchestrator-service-account orchestrator flow-manager-e2e --sequential

      # Wait for kafka and mongo to be ready
      wait_pod --label-selector app.kubernetes.io/component=mongodb --timeout 600
      wait_pod --label-selector app.kubernetes.io/component=kafka --timeout 600
      wait_pod --label-selector app.kubernetes.io/component=zookeeper --timeout 600

  flow-manager-e2e-cicd-run:
    run: |-
      # Running flow-manager-e2e-cicd-deploy pipeline is required before running this
      start_dev flow-manager-e2e
      exec_container --label-selector app.kubernetes.io/component=flow-manager-e2e -n stalker -- /bin/sh -c 'npm run test:e2e:cicd'
      stop_dev --all

images:
  flow-manager:
    image: flow_manager
    dockerfile: flow_manager/Dockerfile.dev
    context: flow_manager
    rebuildStrategy: default

  flow-manager-e2e:
    image: flow_manager_e2e
    dockerfile: flow_manager/Dockerfile.cicd
    context: flow_manager
    rebuildStrategy: always

  cron-service:
    image: cron_service
    dockerfile: cron_service/Dockerfile.dev
    context: cron_service
    rebuildStrategy: default

  ui:
    image: ui
    dockerfile: stalker_ui/Dockerfile.dev
    context: stalker_ui
    rebuildStrategy: default

  orchestrator:
    image: orchestrator
    dockerfile: orchestrator/Dockerfile.dev
    context: orchestrator
    rebuildStrategy: default

  python-job-base:
    image: python-job-base
    dockerfile: jobs/job-base-images/python/Dockerfile
    tags:
      - "latest"
      - "v1"
    context: jobs/job-base-images/python
    rebuildStrategy: always

  nuclei-job-base:
    image: nuclei-job-base
    dockerfile: jobs/job-base-images/python/Dockerfile.nuclei
    tags:
      - "latest"
      - "v1"
    context: jobs/job-base-images/python/
    rebuildStrategy: always

deployments:
  flow-manager:
    helm:
      values:
        containers:
          - env:
              - name: MONGO_ADDRESS
                value: ${FM_MONGO_ADDRESS}
              - name: MONGO_DATABASE_NAME
                value: ${FM_MONGO_DATABASE_NAME}
              - name: FM_JWT_SECRET
                value: ${FM_JWT_SECRET}
              - name: FM_REFRESH_SECRET
                value: ${FM_REFRESH_SECRET}
              - name: KAFKA_URI
                value: ${KAFKA_URI}
              - name: STALKER_URL
                value: ${STALKER_URL}
              - name: MONGO_REPLICA_SET_NAME
                value: ${MONGO_REPLICA_SET_NAME}
              - name: FM_ENVIRONMENT
                value: ${FM_ENVIRONMENT}
              - name: STALKER_CRON_API_TOKEN
                value: ${STALKER_CRON_API_TOKEN}
              - name: SECRET_PUBLIC_RSA_KEY
                value: ${SECRET_PUBLIC_RSA_KEY}
              - name: FM_MONGO_KEY_PASSWORD
                value: ${FM_MONGO_KEY_PASSWORD}

            image: flow_manager
            name: flow-manager-container

        service:
          ports:
            - containerPort: 3000
              port: 3000
              protocol: TCP

  flow-manager-e2e:
    helm:
      values:
        containers:
          - image: flow_manager_e2e
            name: flow-manager-container-e2e
            env:
              - name: MONGO_ADDRESS
                value: ${FM_MONGO_ADDRESS_E2E}
              - name: MONGO_DATABASE_NAME
                # value: stalker-flow-manager-e2e
                value: ${FM_MONGO_DATABASE_NAME}
              - name: FM_JWT_SECRET
                value: ${FM_JWT_SECRET}
              - name: FM_REFRESH_SECRET
                value: ${FM_REFRESH_SECRET}
              - name: KAFKA_URI
                value: ${KAFKA_URI}
              - name: FEATURE_ORCHESTRATOR_ENABLED
                value: "true"
              - name: STALKER_URL
                value: ${STALKER_URL}
              - name: MONGO_REPLICA_SET_NAME
                value: ${MONGO_REPLICA_SET_NAME}
              - name: FM_ENVIRONMENT
                value: "tests"
              - name: STALKER_CRON_API_TOKEN
                value: ${STALKER_CRON_API_TOKEN}
              - name: SECRET_PUBLIC_RSA_KEY
                value: ${SECRET_PUBLIC_RSA_KEY}
              - name: FM_MONGO_KEY_PASSWORD
                value: ${FM_MONGO_KEY_PASSWORD}

        service:
          ports:
            - containerPort: 3000
              port: 3000
              protocol: TCP

  cron-service:
    helm:
      values:
        containers:
          - env:
              - name: MONGO_ADDRESS
                value: ${CRON_SERVICE_MONGO_ADDRESS}
              - name: MONGO_DATABASE_NAME
                value: ${FM_MONGO_DATABASE_NAME}
              - name: MONGO_REPLICA_SET_NAME
                value: ${MONGO_REPLICA_SET_NAME}
              - name: CRON_SERVICE_ENVIRONMENT
                value: ${FM_ENVIRONMENT} # Follows the same environment as FM since they work together
              - name: FM_URL
                value: ${FM_URL}
              - name: STALKER_CRON_API_TOKEN
                value: ${STALKER_CRON_API_TOKEN}
              - name: CRON_SERVICE_MONGO_KEY_PASSWORD
                value: ${CRON_SERVICE_MONGO_KEY_PASSWORD}

            image: cron_service
            name: cron-service-container

        service:
          ports:
            - containerPort: 3000
              port: 3001
              protocol: TCP

  ui:
    helm:
      values:
        containers:
          - env:

            image: ui
            name: ui-container

        service:
          ports:
            - containerPort: 4200
              port: 4200
              protocol: TCP
  mongo: # volumes location: /var/lib/docker/volumes/minikube/_data/hostpath-provisioner/stalker/
    helm:
      chart:
        name: mongodb
        repo: https://charts.bitnami.com/bitnami
        version: "13.9.1"
      values:
        architecture: replicaset
        replicaCount: ${MONGO_REPLICA_SET_COUNT}
        arbiter:
          enabled: false
        externalAccess.enabled: true
        externalAccess.service.type: LoadBalancer
        externalAccess.service.port: 27017
        externalAccess.autoDiscovery.enabled: true
        serviceAccount.create: true
        rbac.create: true
        tls:
          enabled: true
          mode: requireTLS
          autoGenerated: false
          caCert: ${MONGO_CA_CRT}
          caKey: ${MONGO_CA_KEY}
          mTls:
            enabled: true
        service:
          ports:
            mongodb: 27017
        auth:
          rootPassword: ${MONGO_ROOT_PASSWORD}
        initdbScripts:
          init-db.js: |
            db = db.getSiblingDB("stalker");
            db.createCollection("cronsubscriptions");
            var cronRole = {
              role: "cronrole",
              privileges: [
                {
                  resource: {
                    db: "stalker",
                    collection: "cronsubscriptions"
                  },
                  actions: ["find"]
                }
              ],
              roles: []
            };
            db.createRole(cronRole);
            var cronUser = { user: "${MONGO_CRON_SERVICE_USER}", pwd: "${MONGO_CRON_SERVICE_PASSWORD}", roles: ["cronrole"] };
            db.createUser(cronUser);
            var flowRole = { 
              role: "flowrole", 
              privileges: [ 
                {  
                  resource: {
                    db:"stalker", 
                    collection:"" 
                  }, 
                  actions: ["find", "insert", "remove", "update", "createCollection", "changeStream", "createIndex", "convertToCapped"] 
                }
              ], 
              roles:[]
            }
            db.createRole(flowRole);
            var flowUser = { user: "${MONGO_FM_USER}", pwd: "${MONGO_FM_PASSWORD}", roles: ["flowrole"] };
            db.createUser(flowUser);

            // The next one is used for e2e testing
            var flowRole = { 
              role: "flowrolee2e", 
              privileges: [ 
                {  
                  resource: {
                    db:"stalker", 
                    collection:"" 
                  }, 
                  actions: ["find", "insert", "remove", "update", "createCollection", "changeStream", "createIndex", "dropCollection", "convertToCapped"] 
                }
              ], 
              roles:[]
            }
            db.createRole(flowRole);
            var flowUser = { user: "${MONGO_FM_USER_E2E}", pwd: "${MONGO_FM_PASSWORD}", roles: ["flowrolee2e"] };
            db.createUser(flowUser);

  kafka:
    helm:
      chart:
        name: kafka
        repo: https://charts.bitnami.com/bitnami
        version: "21.0.0"

  orchestrator-service-account:
    kubectl:
      manifests:
        - orchestrator/orchestrator-service-account.yml

  orchestrator:
    helm:
      values:
        serviceAccountName: orchestrator-service-account
        containers:
          - env:
              - name: JobsQueue__QueueUri
                value: ${KAFKA_URI}
              - name: SECRET_PRIVATE_RSA_KEY
                value: ${SECRET_PRIVATE_RSA_KEY}

            image: orchestrator
            name: orchestrator-container

        service:
          ports:
            - containerPort: 5135
              port: 5135
              protocol: TCP

  namespaces:
    kubectl:
      manifests:
        - jobs/namespace.yml

  resource-quotas:
    kubectl:
      manifests:
        - jobs/${RESOURCE_QUOTA}

  network-policies:
    kubectl:
      manifests:
        - network-policy.yml
        - stalker_ui/${NETWORK_POLICY}
        - database/${NETWORK_POLICY}
        - flow_manager/${NETWORK_POLICY}
        - cron_service/${NETWORK_POLICY}
        - queue/${NETWORK_POLICY}
        - orchestrator/${NETWORK_POLICY}
        - jobs/${NETWORK_POLICY}

dev:
  mongo:
    labelSelector:
      statefulset.kubernetes.io/pod-name: mongo-mongodb-0
    ports:
      - port: "27017"

  kafka:
    labelSelector:
      app.kubernetes.io/component: kafka
    ports:
      - port: "9092"

  flow-manager:
    labelSelector:
      app.kubernetes.io/component: flow-manager
    container: flow-manager-container
    logs:
      enabled: true
    sync:
      - path: ./flow_manager/src/:/app/src/
        disableDownload: true
    restartHelper:
      inject: false
    ports:
      - port: "3000"

  flow-manager-e2e:
    labelSelector:
      app.kubernetes.io/component: flow-manager-e2e
    container: flow-manager-container-e2e
    logs:
      enabled: true
    sync:
      - path: ./flow_manager/src/:/app/src/
        disableDownload: true
      - path: ./flow_manager/test/:/app/test/
        disableDownload: true
    restartHelper:
      inject: false
    ports:
      - port: "9229"

  cron-service:
    labelSelector:
      app.kubernetes.io/component: cron-service
    container: cron-service-container
    logs:
      enabled: true
    sync:
      - path: ./cron_service/src/:/app/src/
        disableDownload: true
    restartHelper:
      inject: false
    ports:
      - port: "3001:3000"

  ui:
    labelSelector:
      app.kubernetes.io/component: ui
    container: ui-container
    sync:
      - path: ./stalker_ui/src/:/app/src/
        disableDownload: true
    restartHelper:
      inject: false
    ports:
      - port: "4200"

  orchestrator:
    labelSelector:
      app.kubernetes.io/component: orchestrator
    container: orchestrator-container
    sync:
      - path: ./orchestrator/:/app/
        disableDownload: true
        excludePaths:
          - Orchestrator/bin
          - Orchestrator/obj
    restartHelper:
      inject: false
    ports:
      - port: "5135"

hooks:
  - events:
      - after:deploy:mongo
    wait:
      running: true
      terminatedWithCode: 0
    container:
      labelSelector:
        app.kubernetes.io/component: mongodb
      containerName: mongo-container

  - events:
      - after:deploy:flow-manager
    wait:
      running: true
      terminatedWithCode: 0
    container:
      labelSelector:
        app.kubernetes.io/component: flow-manager
      containerName: flow-manager-container

  - events:
      - after:deploy:cron-service
    wait:
      running: true
      terminatedWithCode: 0
    container:
      labelSelector:
        app.kubernetes.io/component: cron-service
      containerName: cron-service-container

  - events:
      - after:deploy:ui
    wait:
      running: true
      terminatedWithCode: 0
    container:
      labelSelector:
        app.kubernetes.io/component: ui
      containerName: ui-container

  - events:
      - after:deploy:orchestrator
    wait:
      running: true
      terminatedWithCode: 0
    container:
      labelSelector:
        app.kubernetes.io/component: orchestrator
      containerName: orchestrator-container

  - events:
      - after:deploy:kafka
    wait:
      running: true
      terminatedWithCode: 0
    container:
      labelSelector:
        app.kubernetes.io/component: kafka
      containerName: kafka-container
